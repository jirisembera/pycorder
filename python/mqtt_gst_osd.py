#!/usr/bin/python3

#################################################################
#
# mqtt_qst_osd.py - MQTT-enabled OSD menu microframework 
#                   for GStreamer
#
# Description:
#   Listens and handles MQTT joystick envents (joystick3.py 
#   recommended). Axes are used internally for menu interaction,
#   buttons may have user-defined actions.
#
#   Axis bindings: Up/Down    - menu scrolling
#                  Left       - back
#                  Right      - trigger action, enter sub-menu
#
#   A menu level is always described by a list of MenuItem 
#   instances. The list can be static (passed to Menuitem
#   constructor) or dynamically generated by a generator function.
#   
#
# Sample menu description:
#
#   def submenu_generator( menu ):
#       return [ MenuItem("Item %d" % i ) for i in range(0, 5) ]
#
#   menu = [
#		MenuItem("Item with callback", callback_action),
#		MenuItem("Item with dynamic submenu", submenu=submenu_generator),
#		MenuItem("Static submenu", submenu=[
#			MenuItem("Submenu1", submenu_callback)
#			MenuItem("Submenu2")
#		])
#	]
#
#
# Note: Root menu cannot be dynamically generated in the current
#       implementation.
#
#################################################################

import paho.mqtt.client
import threading

def _rerender_after( method ):
    def wrapper( self, *args, **kwargs ):
        method( self, *args, **kwargs )
        self._render()
    return wrapper

class MenuItem:
    def __init__(self, text, action=None, enabled=True, submenu=None):
        self.text = text
        self.action = action
        self.enabled = enabled
        self.submenu = submenu

class MqttGstOsd:
    class State:
        def __init__(self, menu, index=0):
            self.menu = menu
            self.index = index
    
    def __init__(self, textoverlay, display_lines, menu, mqtt_host="127.0.0.1", mqtt_port=1883, mqtt_keepalive=60):
        self._textoverlay = textoverlay
        self._display_lines = display_lines
        self._menu = menu
        
        self._mqtt = paho.mqtt.client.Client()
        self._mqtt.on_connect = self._mqtt_connect
        self._mqtt.on_message = self._mqtt_message
        self._mqtt.connect( mqtt_host, mqtt_port, mqtt_keepalive )
        
        self._minimized = False
        self._minimized_placeholder = ""
        
        self._states = [self.State( menu, 0 )]
        self._callbacks = {}
    
    def run(self, threaded=False):
        self._render()
        if threaded:
            thread = threading.Thread(target=self._mqtt.loop_forever)
            thread.daemon = True
            thread.start()
        else:
            self._mqtt.loop_forever()

    @_rerender_after
    def minimize(self, placeholder_text=None):
        self._minimized = True

    @_rerender_after
    def minimize_placeholder(self, placeholder_text=None ):
        if placeholder_text is not None:
            self._minimized_placeholder = placeholder_text
        return self._minimized_placeholder
    
    @_rerender_after
    def restore(self):
        self._minimized = False
    
    def _render(self):
        if self._minimized:
            self._textoverlay.set_property( "text", self._minimized_placeholder )
        else:
            state = self._states[-1]
            items = [" " + x.text for x in state.menu]
            
            if len(items) == 0:
                items = ["<empty>"]
            
            items[state.index] = items[state.index].replace(" ", ">", 1)

            start = max( 0, state.index-2 )            
            end = min( start + self._display_lines, len(items))

            text = "\n".join( items[start:end])
            self._textoverlay.set_property( "text", text )
            #print( items, start, end, text)
            
    
    def _mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe("/device/joystick/2/7")
        client.subscribe("/device/joystick/2/6")
        client.subscribe("/device/joystick/1/+")
    
    @_rerender_after
    def _mqtt_message(self, client, userdata, msg):
        _, _, _, type, number = msg.topic.split("/")
        value = int(msg.payload.decode("ascii"))
        #print( msg.topic, value)

        if type == "1":
            if value > 0:
                self._on_key(int(number))
        elif type == "2":
            if self._minimized:
                return
            if number == "6":
                if value > 0:
                    self._on_down()
                elif value < 0:
                    self._on_up()
            elif number == "7":
                if value > 0:
                    self._on_left()
                elif value < 0:
                    self._on_right()

    def _on_down(self):
        state = self._states[-1]
        state.index += 1
        if state.index >= len(state.menu):
            state.index = 0
   
    def _on_up(self):
        state = self._states[-1]
        state.index -= 1
        if state.index < 0:
            state.index = len(state.menu) - 1
 
    def _on_left(self):
        if len(self._states) > 1:
            self._states.pop()

    def _on_right(self):
        state = self._states[-1]
        current = state.menu[state.index]
        
        if current.action:
            current.action(self)

        if current.submenu:
            submenu = current.submenu
            if callable(submenu):
                submenu = submenu(self) # call submenu generator
            
            if not isinstance(submenu, list):
                raise RuntimeError("Submenu is not list (either hardcoded or returned from generator function)")    

            self._states.append(self.State(submenu))

    def _on_key(self, id):
        if (id in self._callbacks) and (self._callbacks[id]):
            self._callbacks[id](self)
        
        print("key", id)

    def on_button( self, id, callback ):
        self._callbacks[id] = callback
    
    def visible(self):
        return not self._minimized

    def hidden(self):
        return not self.visible()

